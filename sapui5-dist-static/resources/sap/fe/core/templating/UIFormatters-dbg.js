sap.ui.define(["sap/fe/core/converters/MetaModelConverter", "sap/fe/core/helpers/BindingExpression", "sap/fe/core/converters/helpers/BindingHelper", "sap/fe/core/templating/PropertyHelper", "sap/fe/core/templating/DataModelPathHelper"], function (MetaModelConverter, BindingExpression, BindingHelper, PropertyHelper, DataModelPathHelper) {
  "use strict";

  var _exports = {};
  var isPathUpdatable = DataModelPathHelper.isPathUpdatable;
  var getTargetEntitySetPath = DataModelPathHelper.getTargetEntitySetPath;
  var isReadOnlyExpression = PropertyHelper.isReadOnlyExpression;
  var isPathExpression = PropertyHelper.isPathExpression;
  var isNonEditableExpression = PropertyHelper.isNonEditableExpression;
  var isKey = PropertyHelper.isKey;
  var isImmutable = PropertyHelper.isImmutable;
  var isDisabledExpression = PropertyHelper.isDisabledExpression;
  var isComputed = PropertyHelper.isComputed;
  var hasValueHelp = PropertyHelper.hasValueHelp;
  var hasSemanticObject = PropertyHelper.hasSemanticObject;
  var getAssociatedCurrencyProperty = PropertyHelper.getAssociatedCurrencyProperty;
  var getAssociatedUnitProperty = PropertyHelper.getAssociatedUnitProperty;
  var UI = BindingHelper.UI;
  var or = BindingExpression.or;
  var not = BindingExpression.not;
  var isConstant = BindingExpression.isConstant;
  var ifElse = BindingExpression.ifElse;
  var equal = BindingExpression.equal;
  var compileBinding = BindingExpression.compileBinding;
  var and = BindingExpression.and;
  var getInvolvedDataModelObjects = MetaModelConverter.getInvolvedDataModelObjects;
  var convertMetaModelContext = MetaModelConverter.convertMetaModelContext;

  /**
   * Create the expression to generate an "editable" boolean value.
   *
   * @param {PropertyPath} oPropertyPath the input property
   * @param {DataModelObjectPath} oDataModelObjectPath the path to this property object
   * @param {boolean} bAsObject whether or not this should be returned as an object or a binding string
   * @returns {string} the binding string
   */
  var getEditableExpression = function (oPropertyPath, oDataModelObjectPath) {
    var bAsObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return compileBinding(false);
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath; // Editability depends on the field control expression
    // If the Field control is statically in ReadOnly or Inapplicable (disabled) -> not editable
    // If the property is a key -> not editable except in creation if not computed
    // If the property is computed -> not editable
    // If the property is not updatable -> not editable
    // If the property is immutable -> not editable except in creation
    // If the property has a SemanticObject and no ValueList defined -> not editable
    // If the Field control is a path resolving to ReadOnly or Inapplicable (disabled) (<= 1) -> not editable
    // Else, to be editable you need
    // immutable and key while in the creation row
    // ui/isEditable

    var isPathUpdatableExpression = isPathUpdatable(oDataModelObjectPath, oPropertyPath);
    var editableExpression = ifElse(or(not(isPathUpdatableExpression), isComputed(oProperty), isKey(oProperty), isImmutable(oProperty), hasSemanticObject(oProperty) && !hasValueHelp(oProperty), isNonEditableExpression(oProperty)), ifElse((isImmutable(oProperty) || isKey(oProperty)) && !isComputed(oProperty), and(isPathUpdatableExpression, UI.IsTransientBinding), false), UI.IsEditable);

    if (bAsObject) {
      return editableExpression;
    }

    return compileBinding(editableExpression);
  };
  /**
   * Create the expression to generate an "enabled" boolean value.
   *
   * @param {PropertyPath} oPropertyPath the input property
   * @param {boolean} bAsObject whether or not this should be returned as an object or a binding string
   * @returns {string} the binding string
   */


  _exports.getEditableExpression = getEditableExpression;

  var getEnabledExpression = function (oPropertyPath) {
    var bAsObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return compileBinding(true);
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath; // Enablement depends on the field control expression
    // If the Field control is statically in Inapplicable (disabled) -> not enabled

    var enabledExpression = ifElse(isDisabledExpression(oProperty), false, true);

    if (bAsObject) {
      return enabledExpression;
    }

    return compileBinding(enabledExpression);
  };
  /**
   * Create the expression to generate an "editMode" enum value.
   * @param {PropertyPath} oPropertyPath the input property
   * @param {DataModelObjectPath} oDataModelObjectPath the list of involved data model object to reach that property
   * @param {boolean} bAsObject return this as an expression
   * @returns {BindingExpression<string> | ExpressionOrPrimitive<string>} the binding string or part
   */


  _exports.getEnabledExpression = getEnabledExpression;

  var getEditMode = function (oPropertyPath, oDataModelObjectPath) {
    var bAsObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return "Display";
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath; // if the property is not enabled => Disabled
    // if the property is enabled && not editable => ReadOnly
    // if the property is enabled && editable => Editable
    // If there is an associated unit, and it has a field control also use consider the following
    // if the unit field control is readonly -> EditableReadOnly
    // otherwise -> Editable

    var editableExpression = getEditableExpression(oPropertyPath, oDataModelObjectPath, true);
    var enabledExpression = getEnabledExpression(oPropertyPath, true);
    var unitProperty = getAssociatedCurrencyProperty(oProperty) || getAssociatedUnitProperty(oProperty);
    var resultExpression = "Editable";

    if (unitProperty) {
      resultExpression = ifElse(or(isReadOnlyExpression(unitProperty), isComputed(unitProperty)), "EditableReadOnly", "Editable");
    }

    var readOnlyExpression = isReadOnlyExpression(oProperty); // if the property is from a non-updatable entity => Read only mode, previously calculated edit Mode is ignored
    // if the property is from an updatable entity => previously calculated edit Mode expression

    var editModeExpression = ifElse(enabledExpression, ifElse(editableExpression, resultExpression, ifElse(and(!isConstant(readOnlyExpression) && readOnlyExpression, UI.IsEditable), "ReadOnly", "Display")), ifElse(UI.IsEditable, "Disabled", "Display"));

    if (bAsObject) {
      return editModeExpression;
    }

    return compileBinding(editModeExpression);
  };

  _exports.getEditMode = getEditMode;

  var ifUnitEditable = function (oPropertyPath, sEditableValue, sNonEditableValue) {
    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return "Display";
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath;
    var unitProperty = getAssociatedCurrencyProperty(oProperty) || getAssociatedUnitProperty(oProperty);

    if (!unitProperty) {
      return compileBinding(sNonEditableValue);
    }

    var editableExpression = and(not(isReadOnlyExpression(unitProperty)), not(isComputed(unitProperty)));
    return compileBinding(ifElse(editableExpression, sEditableValue, sNonEditableValue));
  };

  _exports.ifUnitEditable = ifUnitEditable;

  var getDisplayMode = function (oPropertyPath, oDataModelObjectPath) {
    var _oProperty$annotation, _oProperty$annotation2, _oTextAnnotation$anno, _oTextAnnotation$anno2, _oTextAnnotation$anno3, _oEntityType$annotati, _oEntityType$annotati2, _oEntityType$annotati3;

    if (!oPropertyPath || typeof oPropertyPath === "string") {
      return "Value";
    }

    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath;
    var oEntityType = oDataModelObjectPath && oDataModelObjectPath.targetEntityType;
    var oTextAnnotation = (_oProperty$annotation = oProperty.annotations) === null || _oProperty$annotation === void 0 ? void 0 : (_oProperty$annotation2 = _oProperty$annotation.Common) === null || _oProperty$annotation2 === void 0 ? void 0 : _oProperty$annotation2.Text;
    var oTextArrangementAnnotation = typeof oTextAnnotation !== "string" && (oTextAnnotation === null || oTextAnnotation === void 0 ? void 0 : (_oTextAnnotation$anno = oTextAnnotation.annotations) === null || _oTextAnnotation$anno === void 0 ? void 0 : (_oTextAnnotation$anno2 = _oTextAnnotation$anno.UI) === null || _oTextAnnotation$anno2 === void 0 ? void 0 : (_oTextAnnotation$anno3 = _oTextAnnotation$anno2.TextArrangement) === null || _oTextAnnotation$anno3 === void 0 ? void 0 : _oTextAnnotation$anno3.toString()) || (oEntityType === null || oEntityType === void 0 ? void 0 : (_oEntityType$annotati = oEntityType.annotations) === null || _oEntityType$annotati === void 0 ? void 0 : (_oEntityType$annotati2 = _oEntityType$annotati.UI) === null || _oEntityType$annotati2 === void 0 ? void 0 : (_oEntityType$annotati3 = _oEntityType$annotati2.TextArrangement) === null || _oEntityType$annotati3 === void 0 ? void 0 : _oEntityType$annotati3.toString());
    var sDisplayValue = oTextAnnotation ? "DescriptionValue" : "Value";

    if (oTextAnnotation && oTextArrangementAnnotation) {
      if (oTextArrangementAnnotation === "UI.TextArrangementType/TextOnly") {
        sDisplayValue = "Description";
      } else if (oTextArrangementAnnotation === "UI.TextArrangementType/TextLast") {
        sDisplayValue = "ValueDescription";
      } else if (oTextArrangementAnnotation === "UI.TextArrangementType/TextSeparate") {
        sDisplayValue = "Value";
      } else {
        //Default should be TextFirst if there is a Text annotation and neither TextOnly nor TextLast are set
        sDisplayValue = "DescriptionValue";
      }
    }

    return sDisplayValue;
  };

  _exports.getDisplayMode = getDisplayMode;

  var getFieldDisplay = function (oPropertyPath, sTargetDisplayMode, oComputedEditMode) {
    var oProperty = isPathExpression(oPropertyPath) && oPropertyPath.$target || oPropertyPath;
    return hasValueHelp(oProperty) ? compileBinding(sTargetDisplayMode) : compileBinding(ifElse(equal(oComputedEditMode, "Editable"), "Value", sTargetDisplayMode));
  };

  _exports.getFieldDisplay = getFieldDisplay;

  var getAlignmentExpression = function (oComputedEditMode) {
    var sAlignDisplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Begin";
    var sAlignEdit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Begin";
    return compileBinding(ifElse(equal(oComputedEditMode, "Display"), sAlignDisplay, sAlignEdit));
  };
  /**
   * Formatter helper to retrieve the converterContext from the metamodel context.
   *
   * @param {Context} oContext the original metamodel context
   * @param {ComputedAnnotationInterface} oInterface the current templating context
   * @returns {object} the converter context representing that object
   */


  _exports.getAlignmentExpression = getAlignmentExpression;

  var getConverterContext = function (oContext, oInterface) {
    if (oInterface && oInterface.context) {
      return convertMetaModelContext(oInterface.context);
    }

    return null;
  };

  getConverterContext.requiresIContext = true;
  /**
   * Formatter helper to retrieve the involved data model object from the metamodel context.
   *
   * @param {Context} oContext the original metamodel context
   * @param {ComputedAnnotationInterface} oInterface the current templating context
   * @returns {object[]} an array of entityset and navproperty involved to get to a specific object in the metamodel
   */

  _exports.getConverterContext = getConverterContext;

  var getDataModelObjectPath = function (oContext, oInterface) {
    if (oInterface && oInterface.context) {
      return getInvolvedDataModelObjects(oInterface.context);
    }

    return null;
  };

  getDataModelObjectPath.requiresIContext = true;
  /**
   * Retrieves the expressionBinding created out of a binding expression.
   *
   * @param {Expression<any>} expression the expression to compile
   * @returns {BindingExpression<string>} the expression binding string
   */

  _exports.getDataModelObjectPath = getDataModelObjectPath;

  var getExpressionBinding = function (expression) {
    return compileBinding(expression);
  };
  /**
   * Retrieve the target entityset for a context path if it exists.
   *
   * @param oContext
   * @returns {string}
   */


  _exports.getExpressionBinding = getExpressionBinding;

  var getTargetEntitySet = function (oContext) {
    if (oContext) {
      var oDataModelPath = getInvolvedDataModelObjects(oContext);
      return getTargetEntitySetPath(oDataModelPath);
    }

    return null;
  };

  _exports.getTargetEntitySet = getTargetEntitySet;
  return _exports;
}, false);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlVJRm9ybWF0dGVycy50cyJdLCJuYW1lcyI6WyJnZXRFZGl0YWJsZUV4cHJlc3Npb24iLCJvUHJvcGVydHlQYXRoIiwib0RhdGFNb2RlbE9iamVjdFBhdGgiLCJiQXNPYmplY3QiLCJjb21waWxlQmluZGluZyIsIm9Qcm9wZXJ0eSIsImlzUGF0aEV4cHJlc3Npb24iLCIkdGFyZ2V0IiwiaXNQYXRoVXBkYXRhYmxlRXhwcmVzc2lvbiIsImlzUGF0aFVwZGF0YWJsZSIsImVkaXRhYmxlRXhwcmVzc2lvbiIsImlmRWxzZSIsIm9yIiwibm90IiwiaXNDb21wdXRlZCIsImlzS2V5IiwiaXNJbW11dGFibGUiLCJoYXNTZW1hbnRpY09iamVjdCIsImhhc1ZhbHVlSGVscCIsImlzTm9uRWRpdGFibGVFeHByZXNzaW9uIiwiYW5kIiwiVUkiLCJJc1RyYW5zaWVudEJpbmRpbmciLCJJc0VkaXRhYmxlIiwiZ2V0RW5hYmxlZEV4cHJlc3Npb24iLCJlbmFibGVkRXhwcmVzc2lvbiIsImlzRGlzYWJsZWRFeHByZXNzaW9uIiwiZ2V0RWRpdE1vZGUiLCJ1bml0UHJvcGVydHkiLCJnZXRBc3NvY2lhdGVkQ3VycmVuY3lQcm9wZXJ0eSIsImdldEFzc29jaWF0ZWRVbml0UHJvcGVydHkiLCJyZXN1bHRFeHByZXNzaW9uIiwiaXNSZWFkT25seUV4cHJlc3Npb24iLCJyZWFkT25seUV4cHJlc3Npb24iLCJlZGl0TW9kZUV4cHJlc3Npb24iLCJpc0NvbnN0YW50IiwiaWZVbml0RWRpdGFibGUiLCJzRWRpdGFibGVWYWx1ZSIsInNOb25FZGl0YWJsZVZhbHVlIiwiZ2V0RGlzcGxheU1vZGUiLCJvRW50aXR5VHlwZSIsInRhcmdldEVudGl0eVR5cGUiLCJvVGV4dEFubm90YXRpb24iLCJhbm5vdGF0aW9ucyIsIkNvbW1vbiIsIlRleHQiLCJvVGV4dEFycmFuZ2VtZW50QW5ub3RhdGlvbiIsIlRleHRBcnJhbmdlbWVudCIsInRvU3RyaW5nIiwic0Rpc3BsYXlWYWx1ZSIsImdldEZpZWxkRGlzcGxheSIsInNUYXJnZXREaXNwbGF5TW9kZSIsIm9Db21wdXRlZEVkaXRNb2RlIiwiZXF1YWwiLCJnZXRBbGlnbm1lbnRFeHByZXNzaW9uIiwic0FsaWduRGlzcGxheSIsInNBbGlnbkVkaXQiLCJnZXRDb252ZXJ0ZXJDb250ZXh0Iiwib0NvbnRleHQiLCJvSW50ZXJmYWNlIiwiY29udGV4dCIsImNvbnZlcnRNZXRhTW9kZWxDb250ZXh0IiwicmVxdWlyZXNJQ29udGV4dCIsImdldERhdGFNb2RlbE9iamVjdFBhdGgiLCJnZXRJbnZvbHZlZERhdGFNb2RlbE9iamVjdHMiLCJnZXRFeHByZXNzaW9uQmluZGluZyIsImV4cHJlc3Npb24iLCJnZXRUYXJnZXRFbnRpdHlTZXQiLCJvRGF0YU1vZGVsUGF0aCIsImdldFRhcmdldEVudGl0eVNldFBhdGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0E7Ozs7Ozs7O0FBUU8sTUFBTUEscUJBQXFCLEdBQUcsVUFDcENDLGFBRG9DLEVBRXBDQyxvQkFGb0MsRUFJMEI7QUFBQSxRQUQ5REMsU0FDOEQsdUVBRHpDLEtBQ3lDOztBQUM5RCxRQUFJLENBQUNGLGFBQUQsSUFBa0IsT0FBT0EsYUFBUCxLQUF5QixRQUEvQyxFQUF5RDtBQUN4RCxhQUFPRyxjQUFjLENBQUMsS0FBRCxDQUFyQjtBQUNBOztBQUNELFFBQU1DLFNBQW1CLEdBQUlDLGdCQUFnQixDQUFDTCxhQUFELENBQWhCLElBQW1DQSxhQUFhLENBQUNNLE9BQWxELElBQStETixhQUEzRixDQUo4RCxDQUs5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFFBQU1PLHlCQUF5QixHQUFHQyxlQUFlLENBQUNQLG9CQUFELEVBQXVCRCxhQUF2QixDQUFqRDtBQUNBLFFBQU1TLGtCQUFrQixHQUFHQyxNQUFNLENBQ2hDQyxFQUFFLENBQ0RDLEdBQUcsQ0FBQ0wseUJBQUQsQ0FERixFQUVETSxVQUFVLENBQUNULFNB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SCxFQUFBQSxtQkFBbUIsQ0FBQ0ssZ0JBQXBCLEdBQXVDLElBQXZDO0FBRUE7Ozs7Ozs7Ozs7QUFPTyxNQUFNQyxzQkFBc0IsR0FBRyxVQUNyQ0wsUUFEcUMsRUFFckNDLFVBRnFDLEVBR1I7QUFDN0IsUUFBSUEsVUFBVSxJQUFJQSxVQUFVLENBQUNDLE9BQTdCLEVBQXNDO0FBQ3JDLGFBQU9JLDJCQUEyQixDQUFDTCxVQUFVLENBQUNDLE9BQVosQ0FBbEM7QUFDQTs7QUFDRCxXQUFPLElBQVA7QUFDQSxHQVJNOztBQVNQRyxFQUFBQSxzQkFBc0IsQ0FBQ0QsZ0JBQXZCLEdBQTBDLElBQTFDO0FBRUE7Ozs7Ozs7OztBQU1PLE1BQU1HLG9CQUFvQixHQUFHLFVBQVNDLFVBQVQsRUFBaUU7QUFDcEcsV0FBTzlELGNBQWMsQ0FBQzhELFVBQUQsQ0FBckI7QUFDQSxHQUZNO0FBSVA7Ozs7Ozs7Ozs7QUFNTyxNQUFNQyxrQkFBa0IsR0FBRyxVQUFTVCxRQUFULEVBQTJDO0FBQzVFLFFBQUlBLFFBQUosRUFBYztBQUNiLFVBQU1VLGNBQWMsR0FBR0osMkJBQTJCLENBQUNOLFFBQUQsQ0FBbEQ7QUFDQSxhQUFPVyxzQkFBc0IsQ0FBQ0QsY0FBRCxDQUE3QjtBQUNBOztBQUVELFdBQU8sSUFBUDtBQUNBLEdBUE0iLCJzb3VyY2VSb290IjoiLiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwic2FwL3VpL21vZGVsL29kYXRhL3Y0XCI7XG5pbXBvcnQgeyBjb252ZXJ0TWV0YU1vZGVsQ29udGV4dCwgZ2V0SW52b2x2ZWREYXRhTW9kZWxPYmplY3RzIH0gZnJvbSBcInNhcC9mZS9jb3JlL2NvbnZlcnRlcnMvTWV0YU1vZGVsQ29udmVydGVyXCI7XG5pbXBvcnQge1xuXHRhbmQsXG5cdEJpbmRpbmdFeHByZXNzaW9uLFxuXHRjb21waWxlQmluZGluZyxcblx0ZXF1YWwsXG5cdEV4cHJlc3Npb24sXG5cdEV4cHJlc3Npb25PclByaW1pdGl2ZSxcblx0aWZFbHNlLFxuXHRpc0NvbnN0YW50LFxuXHRub3QsXG5cdG9yXG59IGZyb20gXCJzYXAvZmUvY29yZS9oZWxwZXJzL0JpbmRpbmdFeHByZXNzaW9uXCI7XG5pbXBvcnQgeyBVSSB9IGZyb20gXCJzYXAvZmUvY29yZS9jb252ZXJ0ZXJzL2hlbHBlcnMvQmluZGluZ0hlbHBlclwiO1xuaW1wb3J0IHtcblx0Z2V0QXNzb2NpYXRlZFVuaXRQcm9wZXJ0eSxcblx0Z2V0QXNzb2NpYXRlZEN1cnJlbmN5UHJvcGVydHksXG5cdGhhc1NlbWFudGljT2JqZWN0LFxuXHRoYXNWYWx1ZUhlbHAsXG5cdGlzQ29tcHV0ZWQsXG5cdGlzRGlzYWJsZWRFeHByZXNzaW9uLFxuXHRpc0ltbXV0YWJsZSxcblx0aXNLZXksXG5cdGlzTm9uRWRpdGFibGVFeHByZXNzaW9uLFxuXHRpc1BhdGhFeHByZXNzaW9uLFxuXHRpc1JlYWRPbmx5RXhwcmVzc2lvblxufSBmcm9tIFwic2FwL2ZlL2NvcmUvdGVtcGxhdGluZy9Qcm9wZXJ0eUhlbHBlclwiO1xuaW1wb3J0IHsgUHJvcGVydHlQYXRoIH0gZnJvbSBcIkBzYXAtdXgvdm9jYWJ1bGFyaWVzLXR5cGVzXCI7XG5pbXBvcnQgeyBQcm9wZXJ0eSB9IGZyb20gXCJAc2FwLXV4L2Fubm90YXRpb24tY29udmVydGVyXCI7XG5pbXBvcnQgeyBQYXRoQW5ub3RhdGlvbkV4cHJlc3Npb24gfSBmcm9tIFwiQHNhcC11eC92b2NhYnVsYXJpZXMtdHlwZXMvdHlwZXMvRWRtXCI7XG5pbXBvcnQgeyBEYXRhTW9kZWxPYmplY3RQYXRoLCBnZXRUYXJnZXRFbnRpdHlTZXRQYXRoLCBpc1BhdGhVcGRhdGFibGUgfSBmcm9tIFwic2FwL2ZlL2NvcmUvdGVtcGxhdGluZy9EYXRhTW9kZWxQYXRoSGVscGVyXCI7XG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5T3JQYXRoPFA+ID0gc3RyaW5nIHwgUCB8IFBhdGhBbm5vdGF0aW9uRXhwcmVzc2lvbjxQPjtcbmV4cG9ydCB0eXBlIE1ldGFNb2RlbENvbnRleHQgPSB7XG5cdCRraW5kOiBzdHJpbmc7XG59O1xuZXhwb3J0IHR5cGUgQ29tcHV0ZWRBbm5vdGF0aW9uSW50ZXJmYWNlID0ge1xuXHRjb250ZXh0OiBDb250ZXh0O1xuXHRhcmd1bWVudHM6IGFueVtdO1xuXHQkJHZhbHVlQXNQcm9taXNlOiBib29sZWFuO1xufTtcbi8qKlxuICogQ3JlYXRlIHRoZSBleHByZXNzaW9uIHRvIGdlbmVyYXRlIGFuIFwiZWRpdGFibGVcIiBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7UHJvcGVydHlQYXRofSBvUHJvcGVydHlQYXRoIHRoZSBpbnB1dCBwcm9wZXJ0eVxuICogQHBhcmFtIHtEYXRhTW9kZWxPYmplY3RQYXRofSBvRGF0YU1vZGVsT2JqZWN0UGF0aCB0aGUgcGF0aCB0byB0aGlzIHByb3BlcnR5IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBiQXNPYmplY3Qgd2hldGhlciBvciBub3QgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWQgYXMgYW4gb2JqZWN0IG9yIGEgYmluZGluZyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBiaW5kaW5nIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2V0RWRpdGFibGVFeHByZXNzaW9uID0gZnVuY3Rpb24oXG5cdG9Qcm9wZXJ0eVBhdGg6IFByb3BlcnR5T3JQYXRoPFByb3BlcnR5Pixcblx0b0RhdGFNb2RlbE9iamVjdFBhdGg/OiBEYXRhTW9kZWxPYmplY3RQYXRoLFxuXHRiQXNPYmplY3Q6IGJvb2xlYW4gPSBmYWxzZVxuKTogQmluZGluZ0V4cHJlc3Npb248Ym9vbGVhbj4gfCBFeHByZXNzaW9uT3JQcmltaXRpdmU8Ym9vbGVhbj4ge1xuXHRpZiAoIW9Qcm9wZXJ0eVBhdGggfHwgdHlwZW9mIG9Qcm9wZXJ0eVBhdGggPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gY29tcGlsZUJpbmRpbmcoZmFsc2UpO1xuXHR9XG5cdGNvbnN0IG9Qcm9wZXJ0eTogUHJvcGVydHkgPSAoaXNQYXRoRXhwcmVzc2lvbihvUHJvcGVydHlQYXRoKSAmJiBvUHJvcGVydHlQYXRoLiR0YXJnZXQpIHx8IChvUHJvcGVydHlQYXRoIGFzIFByb3BlcnR5KTtcblx0Ly8gRWRpdGFiaWxpdHkgZGVwZW5kcyBvbiB0aGUgZmllbGQgY29udHJvbCBleHByZXNzaW9uXG5cdC8vIElmIHRoZSBGaWVsZCBjb250cm9sIGlzIHN0YXRpY2FsbHkgaW4gUmVhZE9ubHkgb3IgSW5hcHBsaWNhYmxlIChkaXNhYmxlZCkgLT4gbm90IGVkaXRhYmxlXG5cdC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBhIGtleSAtPiBub3QgZWRpdGFibGUgZXhjZXB0IGluIGNyZWF0aW9uIGlmIG5vdCBjb21wdXRlZFxuXHQvLyBJZiB0aGUgcHJvcGVydHkgaXMgY29tcHV0ZWQgLT4gbm90IGVkaXRhYmxlXG5cdC8vIElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgdXBkYXRhYmxlIC0+IG5vdCBlZGl0YWJsZVxuXHQvLyBJZiB0aGUgcHJvcGVydHkgaXMgaW1tdXRhYmxlIC0+IG5vdCBlZGl0YWJsZSBleGNlcHQgaW4gY3JlYXRpb25cblx0Ly8gSWYgdGhlIHByb3BlcnR5IGhhcyBhIFNlbWFudGljT2JqZWN0IGFuZCBubyBWYWx1ZUxpc3QgZGVmaW5lZCAtPiBub3QgZWRpdGFibGVcblx0Ly8gSWYgdGhlIEZpZWxkIGNvbnRyb2wgaXMgYSBwYXRoIHJlc29sdmluZyB0byBSZWFkT25seSBvciBJbmFwcGxpY2FibGUgKGRpc2FibGVkKSAoPD0gMSkgLT4gbm90IGVkaXRhYmxlXG5cdC8vIEVsc2UsIHRvIGJlIGVkaXRhYmxlIHlvdSBuZWVkXG5cdC8vIGltbXV0YWJsZSBhbmQga2V5IHdoaWxlIGluIHRoZSBjcmVhdGlvbiByb3dcblx0Ly8gdWkvaXNFZGl0YWJsZVxuXHRjb25zdCBpc1BhdGhVcGRhdGFibGVFeHByZXNzaW9uID0gaXNQYXRoVXBkYXRhYmxlKG9EYXRhTW9kZWxPYmplY3RQYXRoLCBvUHJvcGVydHlQYXRoKTtcblx0Y29uc3QgZWRpdGFibGVFeHByZXNzaW9uID0gaWZFbHNlKFxuXHRcdG9yKFxuXHRcdFx0bm90KGlzUGF0aFVwZGF0YWJsZUV4cHJlc3Npb24pLFxuXHRcdFx0aXNDb21wdXRlZChvUHJvcGVydHkpLFxuXHRcdFx0aXNLZXkob1Byb3BlcnR5KSxcblx0XHRcdGlzSW1tdXRhYmxlKG9Qcm9wZXJ0eSksXG5cdFx0XHRoYXNTZW1hbnRpY09iamVjdChvUHJvcGVydHkpICYmICFoYXNWYWx1ZUhlbHAob1Byb3BlcnR5KSxcblx0XHRcdGlzTm9uRWRpdGFibGVFeHByZXNzaW9uKG9Qcm9wZXJ0eSlcblx0XHQpLFxuXHRcdGlmRWxzZShcblx0XHRcdChpc0ltbXV0YWJsZShvUHJvcGVydHkpIHx8IGlzS2V5KG9Qcm9wZXJ0eSkpICYmICFpc0NvbXB1dGVkKG9Qcm9wZXJ0eSksXG5cdFx0XHRhbmQoaXNQYXRoVXBkYXRhYmxlRXhwcmVzc2lvbiwgVUkuSXNUcmFuc2llbnRCaW5kaW5nKSxcblx0XHRcdGZhbHNlXG5cdFx0KSxcblx0XHRVSS5Jc0VkaXRhYmxlXG5cdCk7XG5cdGlmIChiQXNPYmplY3QpIHtcblx0XHRyZXR1cm4gZWRpdGFibGVFeHByZXNzaW9uO1xuXHR9XG5cdHJldHVybiBjb21waWxlQmluZGluZyhlZGl0YWJsZUV4cHJlc3Npb24pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGV4cHJlc3Npb24gdG8gZ2VuZXJhdGUgYW4gXCJlbmFibGVkXCIgYm9vbGVhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1Byb3BlcnR5UGF0aH0gb1Byb3BlcnR5UGF0aCB0aGUgaW5wdXQgcHJvcGVydHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYkFzT2JqZWN0IHdoZXRoZXIgb3Igbm90IHRoaXMgc2hvdWxkIGJlIHJldHVybmVkIGFzIGFuIG9iamVjdCBvciBhIGJpbmRpbmcgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYmluZGluZyBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVuYWJsZWRFeHByZXNzaW9uID0gZnVuY3Rpb24oXG5cdG9Qcm9wZXJ0eVBhdGg6IFByb3BlcnR5T3JQYXRoPFByb3BlcnR5Pixcblx0YkFzT2JqZWN0OiBib29sZWFuID0gZmFsc2Vcbik6IEJpbmRpbmdFeHByZXNzaW9uPGJvb2xlYW4+IHwgRXhwcmVzc2lvbk9yUHJpbWl0aXZlPGJvb2xlYW4+IHtcblx0aWYgKCFvUHJvcGVydHlQYXRoIHx8IHR5cGVvZiBvUHJvcGVydHlQYXRoID09PSBcInN0cmluZ1wiKSB7XG5cdFx0cmV0dXJuIGNvbXBpbGVCaW5kaW5nKHRydWUpO1xuXHR9XG5cdGNvbnN0IG9Qcm9wZXJ0eSA9IChpc1BhdGhFeHByZXNzaW9uKG9Qcm9wZXJ0eVBhdGgpICYmIG9Qcm9wZXJ0eVBhdGguJHRhcmdldCkgfHwgKG9Qcm9wZXJ0eVBhdGggYXMgUHJvcGVydHkpO1xuXHQvLyBFbmFibGVtZW50IGRlcGVuZHMgb24gdGhlIGZpZWxkIGNvbnRyb2wgZXhwcmVzc2lvblxuXHQvLyBJZiB0aGUgRmllbGQgY29udHJvbCBpcyBzdGF0aWNhbGx5IGluIEluYXBwbGljYWJsZSAoZGlzYWJsZWQpIC0+IG5vdCBlbmFibGVkXG5cdGNvbnN0IGVuYWJsZWRFeHByZXNzaW9uID0gaWZFbHNlKGlzRGlzYWJsZWRFeHByZXNzaW9uKG9Qcm9wZXJ0eSksIGZhbHNlLCB0cnVlKTtcblx0aWYgKGJBc09iamVjdCkge1xuXHRcdHJldHVybiBlbmFibGVkRXhwcmVzc2lvbjtcblx0fVxuXHRyZXR1cm4gY29tcGlsZUJpbmRpbmcoZW5hYmxlZEV4cHJlc3Npb24pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGV4cHJlc3Npb24gdG8gZ2VuZXJhdGUgYW4gXCJlZGl0TW9kZVwiIGVudW0gdmFsdWUuXG4gKiBAcGFyYW0ge1Byb3BlcnR5UGF0aH0gb1Byb3BlcnR5UGF0aCB0aGUgaW5wdXQgcHJvcGVydHlcbiAqIEBwYXJhbSB7RGF0YU1vZGVsT2JqZWN0UGF0aH0gb0RhdGFNb2RlbE9iamVjdFBhdGggdGhlIGxpc3Qgb2YgaW52b2x2ZWQgZGF0YSBtb2RlbCBvYmplY3QgdG8gcmVhY2ggdGhhdCBwcm9wZXJ0eVxuICogQHBhcmFtIHtib29sZWFufSBiQXNPYmplY3QgcmV0dXJuIHRoaXMgYXMgYW4gZXhwcmVzc2lvblxuICogQHJldHVybnMge0JpbmRpbmdFeHByZXNzaW9uPHN0cmluZz4gfCBFeHByZXNzaW9uT3JQcmltaXRpdmU8c3RyaW5nPn0gdGhlIGJpbmRpbmcgc3RyaW5nIG9yIHBhcnRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVkaXRNb2RlID0gZnVuY3Rpb24oXG5cdG9Qcm9wZXJ0eVBhdGg6IFByb3BlcnR5T3JQYXRoPFByb3BlcnR5Pixcblx0b0RhdGFNb2RlbE9iamVjdFBhdGg6IERhdGFNb2RlbE9iamVjdFBhdGgsXG5cdGJBc09iamVjdDogYm9vbGVhbiA9IGZhbHNlXG4pOiBCaW5kaW5nRXhwcmVzc2lvbjxzdHJpbmc+IHwgRXhwcmVzc2lvbk9yUHJpbWl0aXZlPHN0cmluZz4ge1xuXHRpZiAoIW9Qcm9wZXJ0eVBhdGggfHwgdHlwZW9mIG9Qcm9wZXJ0eVBhdGggPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gXCJEaXNwbGF5XCI7XG5cdH1cblx0Y29uc3Qgb1Byb3BlcnR5ID0gKGlzUGF0aEV4cHJlc3Npb24ob1Byb3BlcnR5UGF0aCkgJiYgb1Byb3BlcnR5UGF0aC4kdGFyZ2V0KSB8fCAob1Byb3BlcnR5UGF0aCBhcyBQcm9wZXJ0eSk7XG5cdC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBub3QgZW5hYmxlZCA9PiBEaXNhYmxlZFxuXHQvLyBpZiB0aGUgcHJvcGVydHkgaXMgZW5hYmxlZCAmJiBub3QgZWRpdGFibGUgPT4gUmVhZE9ubHlcblx0Ly8gaWYgdGhlIHByb3BlcnR5IGlzIGVuYWJsZWQgJiYgZWRpdGFibGUgPT4gRWRpdGFibGVcblx0Ly8gSWYgdGhlcmUgaXMgYW4gYXNzb2NpYXRlZCB1bml0LCBhbmQgaXQgaGFzIGEgZmllbGQgY29udHJvbCBhbHNvIHVzZSBjb25zaWRlciB0aGUgZm9sbG93aW5nXG5cdC8vIGlmIHRoZSB1bml0IGZpZWxkIGNvbnRyb2wgaXMgcmVhZG9ubHkgLT4gRWRpdGFibGVSZWFkT25seVxuXHQvLyBvdGhlcndpc2UgLT4gRWRpdGFibGVcblx0Y29uc3QgZWRpdGFibGVFeHByZXNzaW9uID0gZ2V0RWRpdGFibGVFeHByZXNzaW9uKG9Qcm9wZXJ0eVBhdGgsIG9EYXRhTW9kZWxPYmplY3RQYXRoLCB0cnVlKSBhcyBFeHByZXNzaW9uT3JQcmltaXRpdmU8Ym9vbGVhbj47XG5cdGNvbnN0IGVuYWJsZWRFeHByZXNzaW9uID0gZ2V0RW5hYmxlZEV4cHJlc3Npb24ob1Byb3BlcnR5UGF0aCwgdHJ1ZSkgYXMgRXhwcmVzc2lvbk9yUHJpbWl0aXZlPGJvb2xlYW4+O1xuXHRjb25zdCB1bml0UHJvcGVydHkgPSBnZXRBc3NvY2lhdGVkQ3VycmVuY3lQcm9wZXJ0eShvUHJvcGVydHkpIHx8IGdldEFzc29jaWF0ZWRVbml0UHJvcGVydHkob1Byb3BlcnR5KTtcblx0bGV0IHJlc3VsdEV4cHJlc3Npb246IEV4cHJlc3Npb25PclByaW1pdGl2ZTxzdHJpbmc+ID0gXCJFZGl0YWJsZVwiO1xuXHRpZiAodW5pdFByb3BlcnR5KSB7XG5cdFx0cmVzdWx0RXhwcmVzc2lvbiA9IGlmRWxzZShvcihpc1JlYWRPbmx5RXhwcmVzc2lvbih1bml0UHJvcGVydHkpLCBpc0NvbXB1dGVkKHVuaXRQcm9wZXJ0eSkpLCBcIkVkaXRhYmxlUmVhZE9ubHlcIiwgXCJFZGl0YWJsZVwiKTtcblx0fVxuXHRjb25zdCByZWFkT25seUV4cHJlc3Npb24gPSBpc1JlYWRPbmx5RXhwcmVzc2lvbihvUHJvcGVydHkpO1xuXG5cdC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBmcm9tIGEgbm9uLXVwZGF0YWJsZSBlbnRpdHkgPT4gUmVhZCBvbmx5IG1vZGUsIHByZXZpb3VzbHkgY2FsY3VsYXRlZCBlZGl0IE1vZGUgaXMgaWdub3JlZFxuXHQvLyBpZiB0aGUgcHJvcGVydHkgaXMgZnJvbSBhbiB1cGRhdGFibGUgZW50aXR5ID0+IHByZXZpb3VzbHkgY2FsY3VsYXRlZCBlZGl0IE1vZGUgZXhwcmVzc2lvblxuXHRjb25zdCBlZGl0TW9kZUV4cHJlc3Npb24gPSBpZkVsc2UoXG5cdFx0ZW5hYmxlZEV4cHJlc3Npb24sXG5cdFx0aWZFbHNlKFxuXHRcdFx0ZWRpdGFibGVFeHByZXNzaW9uLFxuXHRcdFx0cmVzdWx0RXhwcmVzc2lvbixcblx0XHRcdGlmRWxzZShhbmQoIWlzQ29uc3RhbnQocmVhZE9ubHlFeHByZXNzaW9uKSAmJiByZWFkT25seUV4cHJlc3Npb24sIFVJLklzRWRpdGFibGUpLCBcIlJlYWRPbmx5XCIsIFwiRGlzcGxheVwiKVxuXHRcdCksXG5cdFx0aWZFbHNlKFVJLklzRWRpdGFibGUsIFwiRGlzYWJsZWRcIiwgXCJEaXNwbGF5XCIpXG5cdCk7XG5cdGlmIChiQXNPYmplY3QpIHtcblx0XHRyZXR1cm4gZWRpdE1vZGVFeHByZXNzaW9uO1xuXHR9XG5cdHJldHVybiBjb21waWxlQmluZGluZyhlZGl0TW9kZUV4cHJlc3Npb24pO1xufTtcblxuZXhwb3J0IGNvbnN0IGlmVW5pdEVkaXRhYmxlID0gZnVuY3Rpb24oXG5cdG9Qcm9wZXJ0eVBhdGg6IFByb3BlcnR5T3JQYXRoPFByb3BlcnR5Pixcblx0c0VkaXRhYmxlVmFsdWU6IEV4cHJlc3Npb25PclByaW1pdGl2ZTxzdHJpbmc+LFxuXHRzTm9uRWRpdGFibGVWYWx1ZTogRXhwcmVzc2lvbk9yUHJpbWl0aXZlPHN0cmluZz5cbik6IEJpbmRpbmdFeHByZXNzaW9uPHN0cmluZz4ge1xuXHRpZiAoIW9Qcm9wZXJ0eVBhdGggfHwgdHlwZW9mIG9Qcm9wZXJ0eVBhdGggPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gXCJEaXNwbGF5XCI7XG5cdH1cblx0Y29uc3Qgb1Byb3BlcnR5ID0gKGlzUGF0aEV4cHJlc3Npb24ob1Byb3BlcnR5UGF0aCkgJiYgb1Byb3BlcnR5UGF0aC4kdGFyZ2V0KSB8fCAob1Byb3BlcnR5UGF0aCBhcyBQcm9wZXJ0eSk7XG5cdGNvbnN0IHVuaXRQcm9wZXJ0eSA9IGdldEFzc29jaWF0ZWRDdXJyZW5jeVByb3BlcnR5KG9Qcm9wZXJ0eSkgfHwgZ2V0QXNzb2NpYXRlZFVuaXRQcm9wZXJ0eShvUHJvcGVydHkpO1xuXHRpZiAoIXVuaXRQcm9wZXJ0eSkge1xuXHRcdHJldHVybiBjb21waWxlQmluZGluZyhzTm9uRWRpdGFibGVWYWx1ZSk7XG5cdH1cblx0Y29uc3QgZWRpdGFibGVFeHByZXNzaW9uID0gYW5kKG5vdChpc1JlYWRPbmx5RXhwcmVzc2lvbih1bml0UHJvcGVydHkpKSwgbm90KGlzQ29tcHV0ZWQodW5pdFByb3BlcnR5KSkpO1xuXHRyZXR1cm4gY29tcGlsZUJpbmRpbmcoaWZFbHNlKGVkaXRhYmxlRXhwcmVzc2lvbiwgc0VkaXRhYmxlVmFsdWUsIHNOb25FZGl0YWJsZVZhbHVlKSk7XG59O1xuXG5leHBvcnQgdHlwZSBEaXNwbGF5TW9kZSA9IFwiVmFsdWVcIiB8IFwiRGVzY3JpcHRpb25cIiB8IFwiRGVzY3JpcHRpb25WYWx1ZVwiIHwgXCJWYWx1ZURlc2NyaXB0aW9uXCI7XG5leHBvcnQgY29uc3QgZ2V0RGlzcGxheU1vZGUgPSBmdW5jdGlvbihvUHJvcGVydHlQYXRoOiBQcm9wZXJ0eU9yUGF0aDxQcm9wZXJ0eT4sIG9EYXRhTW9kZWxPYmplY3RQYXRoOiBEYXRhTW9kZWxPYmplY3RQYXRoKTogRGlzcGxheU1vZGUge1xuXHRpZiAoIW9Qcm9wZXJ0eVBhdGggfHwgdHlwZW9mIG9Qcm9wZXJ0eVBhdGggPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gXCJWYWx1ZVwiO1xuXHR9XG5cdGNvbnN0IG9Qcm9wZXJ0eSA9IChpc1BhdGhFeHByZXNzaW9uKG9Qcm9wZXJ0eVBhdGgpICYmIG9Qcm9wZXJ0eVBhdGguJHRhcmdldCkgfHwgKG9Qcm9wZXJ0eVBhdGggYXMgUHJvcGVydHkpO1xuXHRjb25zdCBvRW50aXR5VHlwZSA9IG9EYXRhTW9kZWxPYmplY3RQYXRoICYmIG9EYXRhTW9kZWxPYmplY3RQYXRoLnRhcmdldEVudGl0eVR5cGU7XG5cdGNvbnN0IG9UZXh0QW5ub3RhdGlvbiA9IG9Qcm9wZXJ0eS5hbm5vdGF0aW9ucz8uQ29tbW9uPy5UZXh0O1xuXHRjb25zdCBvVGV4dEFycmFuZ2VtZW50QW5ub3RhdGlvbiA9XG5cdFx0KHR5cGVvZiBvVGV4dEFubm90YXRpb24gIT09IFwic3RyaW5nXCIgJiYgb1RleHRBbm5vdGF0aW9uPy5hbm5vdGF0aW9ucz8uVUk/LlRleHRBcnJhbmdlbWVudD8udG9TdHJpbmcoKSkgfHxcblx0XHRvRW50aXR5VHlwZT8uYW5ub3RhdGlvbnM/LlVJPy5UZXh0QXJyYW5nZW1lbnQ/LnRvU3RyaW5nKCk7XG5cblx0bGV0IHNEaXNwbGF5VmFsdWUgPSBvVGV4dEFubm90YXRpb24gPyBcIkRlc2NyaXB0aW9uVmFsdWVcIiA6IFwiVmFsdWVcIjtcblx0aWYgKG9UZXh0QW5ub3RhdGlvbiAmJiBvVGV4dEFycmFuZ2VtZW50QW5ub3RhdGlvbikge1xuXHRcdGlmIChvVGV4dEFycmFuZ2VtZW50QW5ub3RhdGlvbiA9PT0gXCJVSS5UZXh0QXJyYW5nZW1lbnRUeXBlL1RleHRPbmx5XCIpIHtcblx0XHRcdHNEaXNwbGF5VmFsdWUgPSBcIkRlc2NyaXB0aW9uXCI7XG5cdFx0fSBlbHNlIGlmIChvVGV4dEFycmFuZ2VtZW50QW5ub3RhdGlvbiA9PT0gXCJVSS5UZXh0QXJyYW5nZW1lbnRUeXBlL1RleHRMYXN0XCIpIHtcblx0XHRcdHNEaXNwbGF5VmFsdWUgPSBcIlZhbHVlRGVzY3JpcHRpb25cIjtcblx0XHR9IGVsc2UgaWYgKG9UZXh0QXJyYW5nZW1lbnRBbm5vdGF0aW9uID09PSBcIlVJLlRleHRBcnJhbmdlbWVudFR5cGUvVGV4dFNlcGFyYXRlXCIpIHtcblx0XHRcdHNEaXNwbGF5VmFsdWUgPSBcIlZhbHVlXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vRGVmYXVsdCBzaG91bGQgYmUgVGV4dEZpcnN0IGlmIHRoZXJlIGlzIGEgVGV4dCBhbm5vdGF0aW9uIGFuZCBuZWl0aGVyIFRleHRPbmx5IG5vciBUZXh0TGFzdCBhcmUgc2V0XG5cdFx0XHRzRGlzcGxheVZhbHVlID0gXCJEZXNjcmlwdGlvblZhbHVlXCI7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzRGlzcGxheVZhbHVlIGFzIERpc3BsYXlNb2RlO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEZpZWxkRGlzcGxheSA9IGZ1bmN0aW9uKFxuXHRvUHJvcGVydHlQYXRoOiBQcm9wZXJ0eU9yUGF0aDxQcm9wZXJ0eT4sXG5cdHNUYXJnZXREaXNwbGF5TW9kZTogc3RyaW5nLFxuXHRvQ29tcHV0ZWRFZGl0TW9kZTogRXhwcmVzc2lvbk9yUHJpbWl0aXZlPHN0cmluZz5cbik6IEJpbmRpbmdFeHByZXNzaW9uPHN0cmluZz4ge1xuXHRjb25zdCBvUHJvcGVydHkgPSAoaXNQYXRoRXhwcmVzc2lvbihvUHJvcGVydHlQYXRoKSAmJiBvUHJvcGVydHlQYXRoLiR0YXJnZXQpIHx8IChvUHJvcGVydHlQYXRoIGFzIFByb3BlcnR5KTtcblxuXHRyZXR1cm4gaGFzVmFsdWVIZWxwKG9Qcm9wZXJ0eSlcblx0XHQ/IGNvbXBpbGVCaW5kaW5nKHNUYXJnZXREaXNwbGF5TW9kZSlcblx0XHQ6IGNvbXBpbGVCaW5kaW5nKGlmRWxzZShlcXVhbChvQ29tcHV0ZWRFZGl0TW9kZSwgXCJFZGl0YWJsZVwiKSwgXCJWYWx1ZVwiLCBzVGFyZ2V0RGlzcGxheU1vZGUpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRBbGlnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oXG5cdG9Db21wdXRlZEVkaXRNb2RlOiBFeHByZXNzaW9uPHN0cmluZz4sXG5cdHNBbGlnbkRpc3BsYXk6IHN0cmluZyA9IFwiQmVnaW5cIixcblx0c0FsaWduRWRpdDogc3RyaW5nID0gXCJCZWdpblwiXG4pOiBCaW5kaW5nRXhwcmVzc2lvbjxzdHJpbmc+IHwgRXhwcmVzc2lvbjxzdHJpbmc+IHtcblx0cmV0dXJuIGNvbXBpbGVCaW5kaW5nKGlmRWxzZShlcXVhbChvQ29tcHV0ZWRFZGl0TW9kZSwgXCJEaXNwbGF5XCIpLCBzQWxpZ25EaXNwbGF5LCBzQWxpZ25FZGl0KSk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHRlciBoZWxwZXIgdG8gcmV0cmlldmUgdGhlIGNvbnZlcnRlckNvbnRleHQgZnJvbSB0aGUgbWV0YW1vZGVsIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtDb250ZXh0fSBvQ29udGV4dCB0aGUgb3JpZ2luYWwgbWV0YW1vZGVsIGNvbnRleHRcbiAqIEBwYXJhbSB7Q29tcHV0ZWRBbm5vdGF0aW9uSW50ZXJmYWNlfSBvSW50ZXJmYWNlIHRoZSBjdXJyZW50IHRlbXBsYXRpbmcgY29udGV4dFxuICogQHJldHVybnMge29iamVjdH0gdGhlIGNvbnZlcnRlciBjb250ZXh0IHJlcHJlc2VudGluZyB0aGF0IG9iamVjdFxuICovXG5leHBvcnQgY29uc3QgZ2V0Q29udmVydGVyQ29udGV4dCA9IGZ1bmN0aW9uKG9Db250ZXh0OiBNZXRhTW9kZWxDb250ZXh0LCBvSW50ZXJmYWNlOiBDb21wdXRlZEFubm90YXRpb25JbnRlcmZhY2UpOiBvYmplY3QgfCBudWxsIHtcblx0aWYgKG9JbnRlcmZhY2UgJiYgb0ludGVyZmFjZS5jb250ZXh0KSB7XG5cdFx0cmV0dXJuIGNvbnZlcnRNZXRhTW9kZWxDb250ZXh0KG9JbnRlcmZhY2UuY29udGV4dCk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuZ2V0Q29udmVydGVyQ29udGV4dC5yZXF1aXJlc0lDb250ZXh0ID0gdHJ1ZTtcblxuLyoqXG4gKiBGb3JtYXR0ZXIgaGVscGVyIHRvIHJldHJpZXZlIHRoZSBpbnZvbHZlZCBkYXRhIG1vZGVsIG9iamVjdCBmcm9tIHRoZSBtZXRhbW9kZWwgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge0NvbnRleHR9IG9Db250ZXh0IHRoZSBvcmlnaW5hbCBtZXRhbW9kZWwgY29udGV4dFxuICogQHBhcmFtIHtDb21wdXRlZEFubm90YXRpb25JbnRlcmZhY2V9IG9JbnRlcmZhY2UgdGhlIGN1cnJlbnQgdGVtcGxhdGluZyBjb250ZXh0XG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFuIGFycmF5IG9mIGVudGl0eXNldCBhbmQgbmF2cHJvcGVydHkgaW52b2x2ZWQgdG8gZ2V0IHRvIGEgc3BlY2lmaWMgb2JqZWN0IGluIHRoZSBtZXRhbW9kZWxcbiAqL1xuZXhwb3J0IGNvbnN0IGdldERhdGFNb2RlbE9iamVjdFBhdGggPSBmdW5jdGlvbihcblx0b0NvbnRleHQ6IE1ldGFNb2RlbENvbnRleHQsXG5cdG9JbnRlcmZhY2U6IENvbXB1dGVkQW5ub3RhdGlvbkludGVyZmFjZVxuKTogRGF0YU1vZGVsT2JqZWN0UGF0aCB8IG51bGwge1xuXHRpZiAob0ludGVyZmFjZSAmJiBvSW50ZXJmYWNlLmNvbnRleHQpIHtcblx0XHRyZXR1cm4gZ2V0SW52b2x2ZWREYXRhTW9kZWxPYmplY3RzKG9JbnRlcmZhY2UuY29udGV4dCk7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59O1xuZ2V0RGF0YU1vZGVsT2JqZWN0UGF0aC5yZXF1aXJlc0lDb250ZXh0ID0gdHJ1ZTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGV4cHJlc3Npb25CaW5kaW5nIGNyZWF0ZWQgb3V0IG9mIGEgYmluZGluZyBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7RXhwcmVzc2lvbjxhbnk+fSBleHByZXNzaW9uIHRoZSBleHByZXNzaW9uIHRvIGNvbXBpbGVcbiAqIEByZXR1cm5zIHtCaW5kaW5nRXhwcmVzc2lvbjxzdHJpbmc+fSB0aGUgZXhwcmVzc2lvbiBiaW5kaW5nIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2V0RXhwcmVzc2lvbkJpbmRpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uOiBFeHByZXNzaW9uPGFueT4pOiBCaW5kaW5nRXhwcmVzc2lvbjxzdHJpbmc+IHtcblx0cmV0dXJuIGNvbXBpbGVCaW5kaW5nKGV4cHJlc3Npb24pO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdGFyZ2V0IGVudGl0eXNldCBmb3IgYSBjb250ZXh0IHBhdGggaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSBvQ29udGV4dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRhcmdldEVudGl0eVNldCA9IGZ1bmN0aW9uKG9Db250ZXh0OiBDb250ZXh0KTogc3RyaW5nIHwgbnVsbCB7XG5cdGlmIChvQ29udGV4dCkge1xuXHRcdGNvbnN0IG9EYXRhTW9kZWxQYXRoID0gZ2V0SW52b2x2ZWREYXRhTW9kZWxPYmplY3RzKG9Db250ZXh0KTtcblx0XHRyZXR1cm4gZ2V0VGFyZ2V0RW50aXR5U2V0UGF0aChvRGF0YU1vZGVsUGF0aCk7XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn07XG4iXX0=